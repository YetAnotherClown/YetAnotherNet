{"searchDocs":[{"title":"SendRequest","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/SendRequest","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"SendRequest","url":"/YetAnotherNet/api/SendRequest#functions","content":" ","version":null,"tagName":"h2"},{"title":"to​","type":1,"pageTitle":"SendRequest","url":"/YetAnotherNet/api/SendRequest#to","content":"&lt;/&gt; SendRequest:to(recipient: {Player } | Player | &quot;NET_SERVER&quot;) → () Modifies the recipients of the packet to the one(s) provided in the parameter. ","version":null,"tagName":"h3"},{"title":"Hooks","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/getting-started/hooks","content":"Hooks LuauTypescript Hooks allow you to integrate YetAnotherNet into any game architecture you want. These are simply functions that you can call whenever you want to process your Packets. It's recommended that you set your hooks to run on the Heartbeat using RunService.Heartbeat, so your Networking Code can be scheduled to run frame-by-frame as Net was designed to do. To create a hook, you can use YetAnotherNet.createHook({ Route }) and pass in a table of your Routes, then you can call it whenever you want to process your packets. local RunService = game:GetService(&quot;RunService&quot;) local YetAnotherNet = require(&quot;@packages/YetAnotherNet&quot;) local routes = require(&quot;@shared/routes&quot;) local hook = YetAnotherNet.createHook(routes) RunService.Heartbeat:Connect(hook) ","keywords":"","version":"Next"},{"title":"Loop","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/Loop","content":"Loop A Matter Loop. For technical details, if you were to use a custom Loop object or try to integrate this Net Library in a ECS other than Matter, the YetAnotherNet.start(loop, { Route }) function uses a similar implementation to YetAnotherNet.createHook({ Route }) internally. For more information on this, see [Net.createHook].","keywords":"","version":null},{"title":"Flamework Binary Serializer","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/even-more-compression/flamework-binary-serializer","content":"","keywords":"","version":"Next"},{"title":"🏗️ This page is under construction.​","type":1,"pageTitle":"Flamework Binary Serializer","url":"/YetAnotherNet/docs/even-more-compression/flamework-binary-serializer#️-this-page-is-under-construction","content":" Tracking issue #15  We're still learning the best practices for integrating and using YetAnotherNet with Flamework Binary Serializer, for now check out the GitHub to learn how to use it here.  Also, check out Getting Started with Middleware, Middleware is what you should use to serialize and deserialize your data. ","version":"Next","tagName":"h2"},{"title":"QueryResult","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/QueryResult","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"QueryResult","url":"/YetAnotherNet/api/QueryResult#functions","content":" ","version":null,"tagName":"h2"},{"title":"iterating over QueryResult​","type":1,"pageTitle":"QueryResult","url":"/YetAnotherNet/api/QueryResult#__iter","content":"&lt;/&gt; for number, Player | string, ...any in QueryResult do Iterating over a QueryResult will return the Packets in the QueryResult's Snapshot that match the supplied Senders from [QueryResult:from]. Usage: for pos, sender, ... in net:query():from(...senders) do -- Do something end   ","version":null,"tagName":"h3"},{"title":"from​","type":1,"pageTitle":"QueryResult","url":"/YetAnotherNet/api/QueryResult#from","content":"&lt;/&gt; QueryResult:from( senders: ...sender-- The Senders to filter ) → QueryResult Filters Packets from the QueryResult's Snapshot based on the provided Senders. ","version":null,"tagName":"h3"},{"title":"Bridge","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/Bridge","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Bridge","url":"/YetAnotherNet/api/Bridge#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Bridge","url":"/YetAnotherNet/api/Bridge#new","content":"&lt;/&gt; Bridge.new() → boolean This creates a new Bridge and performs initialization work. You should not create or use Bridges in your code unless creating custom scheduling behavior similar to hooks. If you can use the native Hooks API, it is recommended you do instead of using the Bridge directly. Creating a new Bridge does not create new Remotes, all Remotes are shared by all Bridges. During Mocking, we can change this behavior by overwriting the Bridge:_getRemotes() method.  ","version":null,"tagName":"h3"},{"title":"_sendPayloads​","type":1,"pageTitle":"Bridge","url":"/YetAnotherNet/api/Bridge#_sendPayloads","content":"&lt;/&gt; Bridge:_sendPayloads() → () Before sending the Payloads over the network, this method will attempt to serialize the Payloads into buffers. If the payload fails to serialize, it will send the unserialized payload instead.  ","version":null,"tagName":"h3"},{"title":"_processOutgoingQueue​","type":1,"pageTitle":"Bridge","url":"/YetAnotherNet/api/Bridge#_processOutgoingQueue","content":"&lt;/&gt; Bridge:_processOutgoingQueue() → ClientPayloads,ServerPayload This method will process the OutgoingQueue and pack it into Payloads for use in Bride:_sendPayloads()  ","version":null,"tagName":"h3"},{"title":"snapshot​","type":1,"pageTitle":"Bridge","url":"/YetAnotherNet/api/Bridge#snapshot","content":"&lt;/&gt; Bridge:snapshot() → () Returns a copy of the snapshot. The snapshot is a snapshot of the last frame's IncomingQueue.  ","version":null,"tagName":"h3"},{"title":"step​","type":1,"pageTitle":"Bridge","url":"/YetAnotherNet/api/Bridge#step","content":"&lt;/&gt; Bridge:step() → () This will empty the IncomingQueue and produce a new Snapshot of it, then it will process the OutgoingQueue and send the payloads over the network. You should only use this function if creating custom scheduling behavior similar to the Hooks API, which you should use instead of trying to achieve this behavior using the Bridge itself. ","version":null,"tagName":"h3"},{"title":"Route","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/Route","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#types","content":" ","version":null,"tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#Configuration","content":"&lt;/&gt; interface Configuration { Channel: (&quot;Reliable&quot; | &quot;Unreliable&quot;)?-- Default: Reliable Event: string?-- The event to schedule the Route on in your Matter Loop -- Default: &quot;default&quot; Ratelimit: number?-- Amount of allowed invocations a frame } :::note Ratelimiting is not implemented yet. This feature will come in future versions. ::: Channel Reliable: All packets will be sent and received per frame in order. Unreliable: Packets may be dropped but will be received in order. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#new","content":"&lt;/&gt; Route.new(configuration: Configuration?) → () Creates a new Route with a unique identifier, channel, and event. :::note All Routes with the same Channel will share a single Remote. It's recommended that you run all your Net scheduling code on a single event. :::  ","version":null,"tagName":"h3"},{"title":"query​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#query","content":"&lt;/&gt; Route:query() → QueryResult Allows for iteration of all packets of the previous frame. You can filter by Senders by chaining the QueryResult:from() method onto the query method. :::note Due to certain limitations with the Luau Type System, iterating over the QueryResult Object will not return typed values. In order to fix this, call :__iter() on the QueryResult Object. For example: for i, sender, ... in route:query():__iter() do -- Do something end ::: See Querying Data for more information.  ","version":null,"tagName":"h3"},{"title":"send​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#send","content":"&lt;/&gt; Route:send(...: U...) → SendRequest Sends data to all clients or to specific recipients from the Route's identifier. By default, [Route:send] will send the data to all Clients. You can specify which Clients to receive the data by chaining [SendRequest:to] and passing{ Player }, Player, or Route.Server. See Sending Data for more information.  ","version":null,"tagName":"h3"},{"title":"addIncomingMiddleware​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#addIncomingMiddleware","content":"&lt;/&gt; Route:addIncomingMiddleware((...any): → (...any?)) → () Sets a function to be ran on Incoming packets before they are processed. For example, this would run after the Client receives a Packet from the Server over the network: after calling Route:send() on the Server and before calling Route:query() on the Client. See Middleware for more information.  ","version":null,"tagName":"h3"},{"title":"addOutgoingMiddleware​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#addOutgoingMiddleware","content":"&lt;/&gt; Route:addOutgoingMiddleware((...any): → (...any?)) → () Sets a function to be ran on Outgoing packets before they are sent over the network. For example, this would run before the Server sends a Packet to the Client over the network: after calling Route:send() on the Server and before the Client ever receives the Packet. See Middleware for more information. ","version":null,"tagName":"h3"},{"title":"jecs","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/setup/jecs","content":"","keywords":"","version":"Next"},{"title":"🏗️ This page is under construction.​","type":1,"pageTitle":"jecs","url":"/YetAnotherNet/docs/setup/jecs#️-this-page-is-under-construction","content":" Tracking issue #20  We're still learning the best practices for integrating and using YetAnotherNet with jecs, for now see Other Setups for integrating YetAnotherNet into other game architectures that don't use Matter. You can also see the Matter Setup to see how you would setup and use YetAnotherNet for another ECS library.  Checkout the jecs repository for information on the jecs ECS. ","version":"Next","tagName":"h3"},{"title":"YetAnotherNet","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/YetAnotherNet","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"YetAnotherNet","url":"/YetAnotherNet/api/YetAnotherNet#properties","content":" ","version":null,"tagName":"h2"},{"title":"server​","type":1,"pageTitle":"YetAnotherNet","url":"/YetAnotherNet/api/YetAnotherNet#server","content":"&lt;/&gt; YetAnotherNet.server: &quot;Net_Server&quot; A unique identifier used for to identify the Server when sending/querying.  ","version":null,"tagName":"h3"},{"title":"Route​","type":1,"pageTitle":"YetAnotherNet","url":"/YetAnotherNet/api/YetAnotherNet#Route","content":"&lt;/&gt; YetAnotherNet.Route: Route A uniquely identified Object responsible for handling queries and send requests. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"YetAnotherNet","url":"/YetAnotherNet/api/YetAnotherNet#functions","content":" ","version":null,"tagName":"h2"},{"title":"start​","type":1,"pageTitle":"YetAnotherNet","url":"/YetAnotherNet/api/YetAnotherNet#start","content":"&lt;/&gt; YetAnotherNet.start( loop: Loop,-- A Matter Loop routes: {Route}-- A table of your Routes ) → () Initializes your Routes by adding middleware to your Matter Loop. This ensures that your Routes run between each frame. :::note Please make sure that the event you set in the Configuration, or the default, is the same index you used for yourRunService.Heartbeat event in your Loop:begin() method. Your Routes are meant to run on the heartbeat, like most systems. In some cases you may want to run your Routes on different events, in this case it is acceptable to change it to a different event. :::  ","version":null,"tagName":"h3"},{"title":"createHook​","type":1,"pageTitle":"YetAnotherNet","url":"/YetAnotherNet/api/YetAnotherNet#createHook","content":"&lt;/&gt; YetAnotherNet.createHook( routes: {Route}-- A table of your Routes ) → () → () This function allows you to run Net scheduling code on your own events. When you provide a table of Routes, this function will return another function you can call which will step each Route and process it's Packet Queue. For example, to run scheduling on the Heartbeat: local hook = YetAnotherNet.createHook({ Route }) RunService.Heartbeat:Connect(hook)  ","version":null,"tagName":"h3"},{"title":"Buffer Compression","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/getting-started/buffer-compression","content":"","keywords":"","version":"Next"},{"title":"Hassle-free & Behind the Scenes​","type":1,"pageTitle":"Buffer Compression","url":"/YetAnotherNet/docs/getting-started/buffer-compression#hassle-free--behind-the-scenes","content":" YetAnotherNet will work behind the scenes to automatically compress the data you send for you into Buffers. The library features an internal Ser/Des library to serialize all Luau Datatypes and most Roblox Datatypes.  What's great about this compression is that it requires almost no additional work from the user to use. As long as you use all supported datatypes, YetAnotherNet will pack your data efficiently into buffers with no data-loss.  You can see the list of Supported Datatypes and Unsupported Datatypes on this page.  ","version":"Next","tagName":"h2"},{"title":"Get Even More Buffer Compression​","type":1,"pageTitle":"Buffer Compression","url":"/YetAnotherNet/docs/getting-started/buffer-compression#get-even-more-buffer-compression","content":" Hey! Did you know you could use Middleware to use libraries like Squash and Flamework Binary Serializer?  You can compress your data even more by checking out Compression with Squash and Compression with Flamework Binary Serializer.  ","version":"Next","tagName":"h2"},{"title":"Datatypes​","type":1,"pageTitle":"Buffer Compression","url":"/YetAnotherNet/docs/getting-started/buffer-compression#datatypes","content":" ","version":"Next","tagName":"h2"},{"title":"Supported Datatypes​","type":1,"pageTitle":"Buffer Compression","url":"/YetAnotherNet/docs/getting-started/buffer-compression#supported-datatypes","content":" The following Datatypes can be Serialized by YetAnotherNet, when using these Datatypes, your data will be packed efficiently into a buffer.  Keep in mind that the buffer will be compressed even further by Roblox, the sizes listed here are not the sizes that will actually be sent over the network, the size sent may be lower.  Datatype\tBytesarray (table)\t1-5 bytes per entry + size of value dictionary (table)\t2-10 bytes per key-value pair + size of key and value boolean\t1 number\t4 string\tN/A BrickColor\t2 CFrame\t48 Color3\t12 DateTime\t8 EnumItem\tN/A Instance\t4 Rect\t16 Region3\t60 Region3int16\t12 TweenInfo\t25 + Size of EnumItems UDim\t8 UDim2\t16 Vector2\t8 Vector2int16\t4 Vector3\t12 Vector3int16\t6  Datatypes last updated 04/15/2024, any datatypes added after this date are Unimplemented/Unknown.  If a Datatype not listed here is sent, it will cause the library to send a partially compressed payload over the network, you will lose out on some compression, but the loss will try to be minimized.  ","version":"Next","tagName":"h3"},{"title":"Unsupported Datatypes​","type":1,"pageTitle":"Buffer Compression","url":"/YetAnotherNet/docs/getting-started/buffer-compression#unsupported-datatypes","content":" The following Datatypes are considered Unserializable, either because there is no way to properly serialize/deserialize them, or they have not been implemented.  If it's unimplemented, you may request it be implemented or create a Pull Request to implement it yourself.  Datatype\tStatusAxes\tUnimplemented: niche datatype CatalogSearchParams\tUnimplemented: niche datatype ColorSequence\tUnimplemented: requires ColorSequenceKeypoint ColorSequenceKeypoint\tUnimplemented DockWidgetPluginGuiInfo\tUnimplemented: niche datatype Faces\tUnimplemented FloatCurveKey\tUnimplemented Font\tUnimplemented function\tCannot Serialize/Deserialize NumberRange\tUnimplemented NumberSequence\tUnimplemented: requires NumberSequenceKeypoint NumberSequenceKeypoint\tUnimplemented OverlapParams\tUnimplemented: niche datatype Path2DControlPoint\tUnimplemented PathWaypoint\tUnimplemented PhysicalProperties\tUnimplemented Random\tCannot Serialize/Deserialize Ray\tUnimplemented RaycastParams\tUnimplemented: niche datatype RaycastResult\tCannot Serialize/Deserialize RBXScriptConnection\tCannot Serialize/Deserialize RBXScriptSignal\tCannot Serialize/Deserialize RotationCurveKey\tUnimplemented Secret\tCannot Serialize/Deserialize SharedTable\tCannot Serialize/Deserialize thread\tCannot Serialize/Deserialize  Datatypes last updated 04/12/2024, any datatypes added after this date are Unimplemented/Unknown.  Some additional things to know about the supported datatypes are that tables are treated as dictionaries and arrays. Arrays will always be cheaper than using a Dictionary, make sure that you don't have any &quot;holes&quot; in your arrays, otherwise it will be serialized as an Dictionary. ","version":"Next","tagName":"h3"},{"title":"Other Setups","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/setup/other","content":"Other Setups LuauTypescript You can integrate YetAnotherNet into whatever game architecture you want by creating a Hook using YetAnotherNet.createHook({ Route }) which is identical to the YetAnotherNet.start(loop, { Route }) function. This function will return another function which you can call whenever you want to process your Routes' queues and send/receive your Packets on the Server or Client. Below is a simple example of creating custom scheduling behavior using YetAnotherNet.createHook({ Route }), local RunService = game:GetService(&quot;RunService&quot;) local YetAnotherNet = require(&quot;@packages/YetAnotherNet&quot;) local routes = require(&quot;@shared/routes&quot;) local hook = YetAnotherNet.createHook(routes) RunService.Heartbeat:Connect(hook) ","keywords":"","version":"Next"},{"title":"ECR","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/setup/ecr","content":"","keywords":"","version":"Next"},{"title":"🏗️ This page is under construction.​","type":1,"pageTitle":"ECR","url":"/YetAnotherNet/docs/setup/ecr#️-this-page-is-under-construction","content":" Tracking issue #14  We're still learning the best practices for integrating and using YetAnotherNet with ECR, for now see Other Setups for integrating YetAnotherNet into other game architectures that don't use Matter. You can also see the Matter Setup to see how you would setup and use YetAnotherNet for another ECS library.  You can also checkout ECR — A Luau ECS library. ","version":"Next","tagName":"h3"},{"title":"Middleware","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/getting-started/middleware","content":"Middleware LuauTypescript Middleware is a powerful feature of YetAnotherNet that allows you to validate types before they are processed when sending and receiving data. To create Middleware, you can specify a function in either Route:addIncomingMiddleware() or Route:addOutgoingMiddleware(). local YetAnotherNet = require(&quot;@packages/YetAnotherNet&quot;) local Route = YetAnotherNet.Route type Route&lt;U...&gt; = YetAnotherNet.Route&lt;U...&gt;; local route: Route&lt;number, string, boolean&gt; = Route.new() -- Sets a function to be ran on Incoming packets before they are received over the network route:addIncomingMiddleware(function(number: unknown, string: unknown, boolean: unknown) -- Do something, e.g., Validate Types return number, string, boolean end) -- Sets a function to be ran on Outgoing packets before they are sent over the network route:addOutgoingMiddleware(function(number: number, string: string, boolean: boolean) -- Do something return number, string, boolean end) To validate your types, you can return the values in order to allow it to be processed, or you can drop the packet by returning nil. Dropped packets will never reach your code, meaning you can ensure that the types your code receives are always the types you expect.","keywords":"","version":"Next"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What is this?​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#what-is-this","content":" YetAnotherNet is a networking library for Roblox, or rather its a library that wraps around Roblox's RemoteEvents to solve certain issues and provide new API for networking on Roblox.  Some of the issues this library solves are:  Overhead from RemoteEventsOrdering of Networking EventsLack of Type-Checking and Intellisense for working with RemoteEvents  YetAnotherNet also provides several utilities:  Hassle-free Buffer CompressionStrict Type-Checking &amp; Auto-completionSimple integration with HooksData-driven DesignMiddleware  You can learn more about how YetAnotherNet works and how to use it by visiting Getting Started with Routes. Or, you can keep reading to learn more about the technical details and design choices that went into creating YetAnotherNet.  ","version":"Next","tagName":"h2"},{"title":"Data-driven by design​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#data-driven-by-design","content":" One thing that separates YetAnotherNet from other networking libraries on Roblox is this key design choice. YetAnotherNet was made to work with ECS, a Data-driven approach to game design, which has influenced the design of the library largely and makes it unique from the rest.  With inspiration from Bevy_Renet, a Networking crate for use with the Bevy ECS in Rust, and another networking library on Roblox, BridgeNet2, YetAnotherNet pushes to provide similar functionality to these two libraries for ECS on Roblox.  ","version":"Next","tagName":"h2"},{"title":"Why go for Data-driven?​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#why-go-for-data-driven","content":" Data-driven design opposes Event-driven design, which is what you can commonly see on Roblox, such as RemoteEvents themselves. Event-driven design has it's woes, which is why we opt for ECS and generally Data-driven design.  Event-driven design is sensitive to ordering, this makes it difficult to know when you might get data from an event. To solve this, YetAnotherNet does not use Events, it encourages you to query and send data in an ordered manner frame-by-frame, preferably with ECS.  Since it's encouraged to use ECS with YetAnotherNet, though not required, we suggest reading Matter — Why ECS? by Evaera.  ","version":"Next","tagName":"h3"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#installation","content":" ","version":"Next","tagName":"h2"},{"title":"Wally​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#wally","content":" [dependencies] YetAnotherNet = &quot;yetanotherclown/yetanothernet@0.9.0&quot;   Note: Wally does not export types automatically, if you wish to use Strict Typing with YetAnotherNet, install Wally Package Types with Aftman or Foreman.  ","version":"Next","tagName":"h3"},{"title":"Roblox Typescript​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#roblox-typescript","content":" You can find YetAnotherNet on NPM.  &quot;@rbxts/yetanothernet&quot;: &quot;0.9.0&quot;  ","version":"Next","tagName":"h3"},{"title":"Routes","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/getting-started/routes","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"Routes","url":"/YetAnotherNet/docs/getting-started/routes#configuration","content":" There are a few ways you can configure your Routes:  ChannelEvent All Routes run on one of two channels: Reliable &amp; Unreliable. These channels change the way your packets are sent over the network. Channel\tDescriptionReliable\tPackets are never dropped, and are always ordered. Unreliable\tPackets may be dropped per frame, but are always ordered per frame.    ","version":"Next","tagName":"h2"},{"title":"Type-checking​","type":1,"pageTitle":"Routes","url":"/YetAnotherNet/docs/getting-started/routes#type-checking","content":" Routes can be Type-checked to provide intellisense and auto-completion by providing a type annotation when creating your Routes.  LuauTypescript local YetAnotherNet = require(&quot;@packages/YetAnotherNet&quot;) local Route = YetAnotherNet.Route type Route&lt;U...&gt; = YetAnotherNet.Route&lt;U...&gt;; local route: Route&lt;number, string, boolean&gt; = Route.new() -- Send will expect the types annotated route:send(1, &quot;Hello, world!&quot;, true) -- The returned arguments are typed for pos, num, str, bool in route:query() do -- Do something end In this example, the Route is annotated with the types number, string, boolean, this means that our methods like Route:query() and Route:send() will return or expect these types. This will enable auto-completion and type-checking when working with your Routes, as such it is encouraged you enable Strict Typing to compliment these features.  ","version":"Next","tagName":"h2"},{"title":"Sending​","type":1,"pageTitle":"Routes","url":"/YetAnotherNet/docs/getting-started/routes#sending","content":" LuauTypescript You can use Route:send(...data) to send data over the Route. This data will be processed next frame, which is when you'll be able to query it on the receiving end. local YetAnotherNet = require(&quot;@packages/YetAnotherNet&quot;) local Route = YetAnotherNet.Route type Route&lt;U...&gt; = YetAnotherNet.Route&lt;U...&gt;; local route: Route&lt;number, string, boolean&gt; = Route.new() -- Send will expect the types annotated route:send(1, &quot;Hello, world!&quot;, true) -- The returned arguments are typed for pos, num, str, bool in route:query() do -- Do something end local Route: Route&lt;number, string, boolean&gt; = Route.new() Route:send(5, true, &quot;Hello, world!&quot;) By default, Route:send() will send the Packet of data to all Clients when used on the Server. You can specify a Player or { Player } to send it to by using Route:send():to(recipient).  ","version":"Next","tagName":"h2"},{"title":"Querying​","type":1,"pageTitle":"Routes","url":"/YetAnotherNet/docs/getting-started/routes#querying","content":" LuauTypescript Querying is simple, you can query for Packets by using Route:query() which will return an iterator that will output position, sender, ...data in your for loop. local YetAnotherNet = require(&quot;@packages/YetAnotherNet&quot;) local Route = YetAnotherNet.Route type Route&lt;U...&gt; = YetAnotherNet.Route&lt;U...&gt;; local Route: Route&lt;number, string, boolean&gt; = Route.new() for pos, sender, num, str, bool in Route:query() do -- Do something end When you call the query method, it will take a snapshot of all Packets from the previous frame and filter it for you, such as only returning Packets from the Route the method was called on. Or, you can also filter out senders by calling Route:query():from(...sender) on the QueryResult and putting any values of type { Player } | Player | YetAnotherNet.server in the arguments. ","version":"Next","tagName":"h2"},{"title":"Squash","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/even-more-compression/squash","content":"","keywords":"","version":"Next"},{"title":"Why Also Use Squash​","type":1,"pageTitle":"Squash","url":"/YetAnotherNet/docs/even-more-compression/squash#why-also-use-squash","content":" Why should you also use Squash when YetAnotherNet already has a SerDes library internally? Good Question.  YetAnotherNet's SerDes library is completely dynamic, outputting a buffer with a format that can be read without any context. With Squash, you can explicitly define the data you send and compress it without the overhead of the Internal SerDes Library's dynamic nature.  Here are some comparisons between the two from feeding them the same example data:  Data\tYetAnotherNet (bytes)\tSquash (bytes)Array\t45\t37 Map\t66\t40 Record\t283\t89 Tuple\t88\t31  Last updated 07/07/2024, size of data is subject to change.  See Data used for comparisons Array​ local array = {1, 2, 3, 4, 5.5, 6.6, -7.7, -8.9, 10.01} Map​ local map = { [Vector2.new(1, 2)] = Vector3.new(1, 2, 3), [Vector2.new(4, 29)] = Vector3.new(4, 29, 33), [Vector2.new(72, 483)] = Vector3.new(72, 483, 555), } Record​ local record = { position = Vector2.new(287.3855, -13486.3), health = 9, name = &quot;Cedrick&quot;, poisoned = true, items = { { name = 'Lantern', count = 2 }, { name = 'Waterskin', count = 1 }, { name = 'Map', count = 4 }, }, inns = { ['The Copper Cauldron'] = true, Infirmary = true, ['His Recess'] = true, } } Tuple​ local a, b, c, d = Vector3.new(123456789, 1, 0), CFrame.new(1, 2, 3), BrickColor.new(93), Enum.HumanoidStateType.Freefall   These comparisons show the scale of the tradeoff YetAnotherNet took for Dynamic compression, not to mention Squash is very well made. YetAnotherNet primarily relies on Roblox's built-in compression of Buffers when sending over the network, so it isn't as bad as it seems.  Luckily, you can use Squash with YetAnotherNet without any large overhead as it accepts buffers as valid types to send over the network!  ","version":"Next","tagName":"h2"},{"title":"How To Luau​","type":1,"pageTitle":"Squash","url":"/YetAnotherNet/docs/even-more-compression/squash#how-to-luau","content":" local Squash = require(&quot;@packages/Squash&quot;) local YetAnotherNet = require(&quot;@packages/YetAnotherNet&quot;) local Route = YetAnotherNet.Route type Route&lt;U...&gt; = YetAnotherNet.Route&lt;U...&gt; local route: Route&lt;number, string, boolean&gt; = Route.new({}) local tuple = Squash.tuple( Squash.T(Squash.number(8)), Squash.T(Squash.string()), Squash.T(Squash.boolean()) ) -- Decompress route:addIncomingMiddleware(function(_buffer: unknown) if type(_buffer) ~= &quot;buffer&quot; then return nil -- Drop packet on failed type validation end local cursor = Squash.frombuffer(_buffer) return tuple.des(cursor) end) -- Compress route:addOutgoingMiddleware(function(number, string, boolean) local cursor = Squash.cursor() tuple.ser(cursor, number, string, boolean) return Squash.tobuffer(cursor) end) return { route = route, }   ","version":"Next","tagName":"h2"},{"title":"How To Typescript​","type":1,"pageTitle":"Squash","url":"/YetAnotherNet/docs/even-more-compression/squash#how-to-typescript","content":" You can find the TypeScript Types for Squash on npm.  import Squash from &quot;@rbxts/squash&quot;; import Route from &quot;@rbxts/yetanothernet&quot;; const route: Route&lt;[number, boolean, string]&gt; = new Route({ Channel: &quot;Reliable&quot;, Event: undefined, }); const tuple = Squash.tuple( Squash.number(8), Squash.string(), Squash.boolean() ); // Decompress route.addIncomingMiddleware(function (_buffer) { if (!typeIs(_buffer, &quot;buffer&quot;)) { return undefined; // Drop packet on failed type validation } const cursor = Squash.frombuffer(_buffer); return tuple.des(cursor); }); // Compress route.addOutgoingMiddleware(function (number, string, boolean) { const cursor = Squash.cursor(); tuple.ser(cursor, number, string, boolean); return $tuple(Squash.tobuffer(cursor)); }); export = { route: route, };  ","version":"Next","tagName":"h2"},{"title":"Matter","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/setup/matter","content":"Matter tip Check out the adapted version of the Matter Example game to see how it's used in a real game. See all of YetAnotherNet's example projects in the repository. LuauTypescript Being initially made for the Matter ECS, YetAnotherNet provides a simple function for scheduling your Routes to run on your Matter Loop. Firstly, create a routes.luau ModuleScript in ReplicatedStorage to strictly declare your Routes. shared/routes.luau local YetAnotherNet = require(&quot;@shared/routes&quot;) local Route = YetAnotherNet.Route type Route&lt;U...&gt; = YetAnotherNet.Route&lt;U...&gt;; local defaultConfiguration = { Channel = &quot;Reliable&quot;, Event = &quot;default&quot;, } -- Payload for replicating Entities type EntityPayload = { [string]: { -- EntityId [string]: { -- Component name data: ComponentInstance&lt;T&gt; } } } -- Replicate Matter Components local MatterReplication: Route&lt;EntityPayload&gt; = Route.new(defaultConfiguration) -- Signal that the Player has loaded local PlayerLoaded: Route&lt;boolean&gt; = Route.new(defaultConfiguration) return { MatterReplication = MatterReplication, PlayerLoaded = PlayerLoaded, } And now in the same script where you create your Matter Loop, you can run the YetAnotherNet.start(Loop, { Route })function to schedule your Routes to run on Matter's Middleware. init.server.luau / init.client.luau local RunService = game:GetService(&quot;RunService&quot;) local Matter = require(&quot;@packages/Matter&quot;) local World = Matter.World local Loop = Matter.Loop local YetAnotherNet = require(&quot;@packages/YetAnotherNet&quot;) local routes = require(&quot;@shared/routes&quot;) local world = World.new() local loop = Loop.new(world) -- Schedules your Routes YetAnotherNet.start(loop, routes) local systems = {} for _, child in script.systems:GetChildren() do if child:IsA(&quot;ModuleScript&quot;) then table.insert(systems, require(child)) end end loop:scheduleSystems(systems) -- Schedule systems after running ``YetAnotherNet.start()`` -- Begin the loop and make sure the ``Event`` key in your Routes configuration are added here loop:begin({ default = RunService.Heartbeat }) Finally, in a Matter System we can use our routes.luau ModuleScript to access our Routes and use them within our Systems. systems/exampleSystem.luau local routes = require(&quot;@shared/routes&quot;) local PlayerLoaded = routes.PlayerLoaded local function exampleSystem(world) -- Query through every networking call that frame on the Server for i, player, ...data in PlayerLoaded:query() do -- Do something end -- Query through every networking call that frame on the Client for i, _, ...data in PlayerLoaded:query() do -- Do something end -- Send data from the Client to the Server PlayerLoaded:send(...data) -- Send data to a Client from the Server PlayerLoaded:send(...data):to(Player) end ","keywords":"","version":"Next"}],"options":{"id":"default"}}