[{"title":"ECR","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/setup/ecr","content":"","keywords":""},{"title":"🏗️ This page is under construction.​","type":1,"pageTitle":"ECR","url":"/YetAnotherNet/docs/setup/ecr#️-this-page-is-under-construction","content":"We're still learning the best practices for integrating and using Net with ECR, for now see Other Setups for integrating Net into other game architectures that don't use Matter. You can also see the Matter Setup to see how you would setup and use Net for another ECS library. You can also checkout ECR — A Luau ECS library. "},{"title":"QueryResult","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/QueryResult","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"QueryResult","url":"/YetAnotherNet/api/QueryResult#functions","content":" "},{"title":"iterating over QueryResult​","type":1,"pageTitle":"QueryResult","url":"/YetAnotherNet/api/QueryResult#__iter","content":"&lt;/&gt; for number, Player | string, ...any in QueryResult do Iterating over a QueryResult will return the Packets in the QueryResult's Snapshot that match the supplied Senders from QueryResult:from. Usage: for pos, sender, ... in net:query():from(...senders) do -- Do something end   "},{"title":"from​","type":1,"pageTitle":"QueryResult","url":"/YetAnotherNet/api/QueryResult#from","content":"&lt;/&gt; QueryResult:from( senders: ...sender-- The Senders to filter ) → QueryResult Filters Packets from the QueryResult's Snapshot based on the provided Senders. "},{"title":"Loop","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/Loop","content":"On this page Loop A Matter Loop. For technical details, if you were to use a custom Loop object or try to integrate this Net Library in a ECS other than Matter, the Net.start(loop, { Route }) function uses a similar implementation to Net.createHook({ Net }) internally. For more information on this, see Net.createHook.","keywords":""},{"title":"Net","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/Net","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Net","url":"/YetAnotherNet/api/Net#properties","content":" "},{"title":"server​","type":1,"pageTitle":"Net","url":"/YetAnotherNet/api/Net#server","content":"&lt;/&gt; Net.server: &quot;Net_Server&quot; A unique identifier used for to identify the Server when sending/querying.  "},{"title":"Route​","type":1,"pageTitle":"Net","url":"/YetAnotherNet/api/Net#Route","content":"&lt;/&gt; Net.Route: Route A uniquely identified Object responsible for handling queries and send requests. "},{"title":"Functions​","type":1,"pageTitle":"Net","url":"/YetAnotherNet/api/Net#functions","content":" "},{"title":"start​","type":1,"pageTitle":"Net","url":"/YetAnotherNet/api/Net#start","content":"&lt;/&gt; Net.start( loop: Loop,-- A Matter Loop routes: {Route}-- A table of your Routes ) → () Initializes your Routes by adding middleware to your Matter Loop. This ensures that your Routes run between each frame. note Please make sure that the event you set in the Configuration, or the default, is the same index you used for yourRunService.Heartbeat event in your Loop:begin() method. Your Routes are meant to run on the heartbeat, like most systems. In some cases you may want to run your Routes on different events, in this case it is acceptable to change it to a different event.  "},{"title":"createHook​","type":1,"pageTitle":"Net","url":"/YetAnotherNet/api/Net#createHook","content":"&lt;/&gt; Net.createHook( routes: {Net}-- A table of your Routes ) → () → () This function allows you to run Net scheduling code on your own events. When you provide a table of Routes, this function will return another function you can call which will step each Route and process it's Packet Queue. For example, to run scheduling on the Heartbeat: local hook = Net.createHook({ Route }) RunService.Heartbeat:Connect(hook)  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/intro","content":"","keywords":""},{"title":"What is this?​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#what-is-this","content":"Net is a networking library for Roblox, or rather its a library that wraps around Roblox's RemoteEvents to solve certain issues and provide new API for networking on Roblox. Some of the issues this library solves are: Overhead from RemoteEventsOrdering of Networking EventsLack of Type-Checking and Intellisense for working with RemoteEvents Net also provides several utilities: MiddlewareStrict Type-Checking &amp; Auto-completionSimple integration with HooksData-driven Design You can learn more about how Net works and how to use it by visiting Getting Started with Routes. Or, you can keep reading to learn more about the technical details and design choices that went into creating Net. "},{"title":"Data-driven by design​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#data-driven-by-design","content":"One thing that separates Net from other networking libraries on Roblox is this key design choice. Net was made to work with ECS, a Data-driven approach to game design, which has influenced the design of the library largely and makes it unique from the rest. With inspiration from Bevy_Renet, a Networking crate for use with the Bevy ECS in Rust, and another networking library on Roblox, BridgeNet2, Net pushes to provide similar functionality to these two libraries for ECS on Roblox. "},{"title":"Why go for Data-driven?​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#why-go-for-data-driven","content":"Data-driven design opposes Event-driven design, which is what you can commonly see on Roblox, such as RemoteEvents themselves. Event-driven design has it's woes, which is why we opt for ECS and generally Data-driven design. Event-driven design is sensitive to ordering, this makes it difficult to know when you might get data from an event. To solve this, Net does not use Events, it encourages you to query and send data in an ordered manner frame-by-frame, preferably with ECS. Since it's encouraged to use ECS with Net, though not required, we suggest reading Matter — Why ECS? by Evaera. "},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#installation","content":""},{"title":"Wally​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#wally","content":"[dependencies] Net = &quot;yetanotherclown/yetanothernet@0.7.0&quot;  Note: Wally does not export types automatically, if you wish to use Strict Typing with Net, install Wally Package Types with Aftman. "},{"title":"Roblox Typescript​","type":1,"pageTitle":"Introduction","url":"/YetAnotherNet/docs/intro#roblox-typescript","content":"You can find Net as YetAnotherNet on NPM. &quot;@rbxts/yetanothernet&quot;: &quot;0.7.0-beta.3&quot;  "},{"title":"Route","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/Route","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#types","content":" "},{"title":"Configuration​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#Configuration","content":"&lt;/&gt; interface Configuration { Channel: &quot;Reliable&quot; | &quot;Unreliable&quot;-- Default: Reliable Event: string-- The event to schedule the Route on in your Matter Loop -- Default: &quot;default&quot; Ratelimit: number-- Amount of allowed invocations a frame }  note As of v0.5.0, Ratelimiting is not implemented. This feature will come in future versions. Channel Reliable: All packets will be sent and received per frame in order. Unreliable: Packets may be dropped but will be received in order. "},{"title":"Functions​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#new","content":"&lt;/&gt; Route.new(configuration: Configuration?) → () Creates a new Route with a unique identifier, channel, and event. note All Routes with the same Channel will share a single Remote. It's recommended that you run all your Net scheduling code on a single event.  "},{"title":"query​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#query","content":"&lt;/&gt; Route:query() → QueryResult Allows for iteration of all packets of the previous frame. You can filter by Senders by chaining the QueryResult:from() method onto the query method. note Due to certain limitations with the Luau Type System, iterating over the QueryResult Object will not return typed values. In order to fix this, call :__iter() on the QueryResult Object. For example: for i, sender, ... in route:query():__iter() do -- Do something end See Querying Data for more information.  "},{"title":"send​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#send","content":"&lt;/&gt; Route:send() → () Sends data to all clients or to specific recipients from the Route's identifier. By default, Route:send will send the data to all Clients. You can specify which Clients to receive the data by chaining SendRequest:to and passing { Player }, Player, or Route.Server. See Sending Data for more information.  "},{"title":"addIncomingMiddleware​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#addIncomingMiddleware","content":"&lt;/&gt; Route:addIncomingMiddleware() → () Sets a function to be ran on Incoming packets before they are processed. For example, this would run after the Client receives a Packet from the Server over the network: after calling Route:send() on the Server and before calling Route:query() on the Client. See Middleware for more information.  "},{"title":"addOutgoingMiddleware​","type":1,"pageTitle":"Route","url":"/YetAnotherNet/api/Route#addOutgoingMiddleware","content":"&lt;/&gt; Route:addOutgoingMiddleware() → () Sets a function to be ran on Outgoing packets before they are sent over the network. For example, this would run before the Server sends a Packet to the Client over the network: after calling Route:send() on the Server and before the Client ever receives the Packet. See Middleware for more information. "},{"title":"Hooks","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/getting-started/hooks","content":"Hooks LuauTypescript Hooks allow you to integrate Net into any game architecture you want. These are simply functions that you can call whenever you want to process your Packets. It's recommended that you set your hooks to run on the Heartbeat using RunService.Heartbeat, so your Networking Code can be scheduled to run frame-by-frame as Net was designed to do. To create a hook, you can use Net.createHook({ Route }) and pass in a table of your Routes, then you can call it whenever you want to process your packets. local RunService = game:GetService(&quot;RunService&quot;) local Net = require(&quot;Net.luau&quot;) local routes = require(&quot;routes.luau&quot;) local hook = Net.createHook(routes) RunService.Heartbeat:Connect(hook) ","keywords":""},{"title":"SendRequest","type":0,"sectionRef":"#","url":"/YetAnotherNet/api/SendRequest","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"SendRequest","url":"/YetAnotherNet/api/SendRequest#functions","content":" "},{"title":"to​","type":1,"pageTitle":"SendRequest","url":"/YetAnotherNet/api/SendRequest#to","content":"&lt;/&gt; SendRequest:to(recipient: {Player } | Player | &quot;NET_SERVER&quot;) → () Modifies the recipients of the packet to the one(s) provided in the parameter. "},{"title":"Middleware","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/getting-started/middleware","content":"","keywords":""},{"title":"Compression​","type":1,"pageTitle":"Middleware","url":"/YetAnotherNet/docs/getting-started/middleware#compression","content":"To compress/decompress your data, you can use a library like Squash to serialize and deserialize your data. Simply return the types in order as a tuple, you can use the event parameter to determine whether to compress or decompress your data. local Squash = require(&quot;Squash.luau&quot;) local Net = require(&quot;Net.luau&quot;) local Route = Net.Route type Route&lt;U...&gt; = Net.Route&lt;U...&gt;; local route: Route&lt;string, number&gt; = Route.new({ Channel = &quot;Reliable&quot;, }) -- Deserialize Packets before returning route:addIncomingMiddleware(function(str, bool) local values: { any } = {} local alphabet = Squash.string.alphabet(str) -- Type-check returned values; -- Squash serializes types into other types, like string if type(str) ~= &quot;string&quot; or type(boolean) ~= &quot;string&quot; then return end values = { Squash.string.des(str, alphabet), Squash.boolean.des(boolean), } return table.unpack(values) end) -- Serialize Packets before sending route:addOutgoingMiddleware(function(str, bool) local values: { any } = {} local alphabet = Squash.string.alphabet(str) -- Type-check sent values, -- Should be of the provided types U... in Net&lt;U...&gt; if type(str) ~= &quot;string&quot; or type(boolean) ~= &quot;boolean&quot; then return end values = { Squash.string.ser(str, alphabet), Squash.boolean.ser(boolean), } return table.unpack(values) end)  "},{"title":"Other Setups","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/setup/other","content":"Other Setups LuauTypescript You can integrate Net into whatever game architecture you want by creating a Hook using Net.createHook({ Route }) which is identical to the Net.start(loop, { Route }) function. This function will return another function which you can call whenever you want to process your Routes' queues and send/receive your Packets on the Server or Client. Below is a simple example of creating custom scheduling behavior using Net.createHook({ Route }), local RunService = game:GetService(&quot;RunService&quot;) local Net = require(&quot;Net.luau&quot;) local routes = require(&quot;routes.luau&quot;) local hook = Net.createHook(routes) RunService.Heartbeat:Connect(hook) ","keywords":""},{"title":"Routes","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/getting-started/routes","content":"","keywords":""},{"title":"Configuration​","type":1,"pageTitle":"Routes","url":"/YetAnotherNet/docs/getting-started/routes#configuration","content":"There are a few ways you can configure your Routes: ChannelEvent All Routes run on one of two channels: Reliable &amp; Unreliable. These channels change the way your packets are sent over the network. Channel\tDescriptionReliable\tPackets are never dropped, and are always ordered. Unreliable\tPackets may be dropped per frame, but are always ordered per frame.  "},{"title":"Type-checking​","type":1,"pageTitle":"Routes","url":"/YetAnotherNet/docs/getting-started/routes#type-checking","content":"Routes can be Type-checked to provide intellisense and auto-completion by providing a type annotation when creating your Routes. LuauTypescript local Net = require(&quot;Net.luau&quot;) local Route = Net.Route type Route&lt;U...&gt; = Net.Route&lt;U...&gt;; local route: Route&lt;number, string, boolean&gt; = Route.new() -- Send will expect the types annotated route:send(1, &quot;Hello, world!&quot;, true) -- The returned arguments are typed for pos, num, str, bool in route:query() do -- Do something end In this example, the Route is annotated with the types number, string, boolean, this means that our methods like Route:query() and Route:send() will return or expect these types. This will enable auto-completion and type-checking when working with your Routes, as such it is encouraged you enable Strict Typing to compliment these features. "},{"title":"Sending​","type":1,"pageTitle":"Routes","url":"/YetAnotherNet/docs/getting-started/routes#sending","content":"LuauTypescript You can use Route:send(...data) to send data over the Route. This data will be processed next frame, which is when you'll be able to query it on the receiving end. local Net = require(&quot;Net.luau&quot;) local Route = Net.Route type Route&lt;U...&gt; = Net.Route&lt;U...&gt;; local route: Route&lt;number, string, boolean&gt; = Route.new() -- Send will expect the types annotated route:send(1, &quot;Hello, world!&quot;, true) -- The returned arguments are typed for pos, num, str, bool in route:query() do -- Do something end local Route: Net&lt;number, string, boolean&gt; = Net.new() Route:send(5, true, &quot;Hello, world!&quot;) By default, Route:send() will send the Packet of data to all Clients when used on the Server. You can specify a Player or { Player } to send it to by using Route:send():to(recipient). "},{"title":"Querying​","type":1,"pageTitle":"Routes","url":"/YetAnotherNet/docs/getting-started/routes#querying","content":"LuauTypescript Querying is simple, you can query for Packets by using Route:query() which will return an iterator that will output position, sender, ...data in your for loop. local Net = require(&quot;Net.luau&quot;) local Route = Net.Route type Route&lt;U...&gt; = Net.Route&lt;U...&gt;; local Route: Route&lt;number, string, boolean&gt; = Route.new() for pos, sender, num, str, bool in Route:query() do -- Do something end When you call the query method, it will take a snapshot of all Packets from the previous frame and filter it for you, such as only returning Packets from the Route the method was called on. Or, you can also filter out senders by calling Route:query():from(...sender) on the QueryResult and putting any values of type { Player } | Player | Net.server in the arguments. "},{"title":"Matter","type":0,"sectionRef":"#","url":"/YetAnotherNet/docs/setup/matter","content":"Matter tip Check out the adapted version of the Matter Example game to see how it's used in a real game. See all of Net's example projects in the repository. LuauTypescript Being initially made for the Matter ECS, Net provides a simple function for scheduling your Routes to run on your Matter Loop. Firstly, create a routes.luau ModuleScript in ReplicatedStorage to strictly declare your Routes. routes.luau local Net = require(&quot;Net.luau&quot;) local Route = Net.Route type Route&lt;U...&gt; = Net.Route&lt;U...&gt;; local defaultConfiguration = { Channel = &quot;Reliable&quot;, Event = &quot;default&quot;, } -- Payload for replicating Entities type EntityPayload = { [string]: { -- EntityId [string]: { -- Component name data: ComponentInstance&lt;T&gt; } } } -- Replicate Matter Components local MatterReplication: Net&lt;EntityPayload&gt; = Net.new(defaultConfiguration) -- Signal that the Player has loaded local PlayerLoaded: Net&lt;boolean&gt; = Net.new(defaultConfiguration) return { MatterReplication = MatterReplication, PlayerLoaded = PlayerLoaded, } And now in the same script where you create your Matter Loop, you can run the Net.start(Loop, { Net })function to schedule your Routes to run on Matter's Middleware. init.server.luau / init.client.luau local Matter = require(&quot;Matter.luau&quot;) local World = Matter.World local Loop = Matter.Loop local Net = require(&quot;Net.luau&quot;) local routes = require(&quot;routes.luau&quot;) local world = World.new() local loop = Loop.new(world) -- Schedules your Routes Net.start(loop, routes) local systems = {} for _, child in script.systems:GetChildren() do if child:IsA(&quot;ModuleScript&quot;) then table.insert(systems, require(child)) end end loop:scheduleSystems(systems) -- Schedule systems after running ``Net.start()`` -- Begin the loop and make sure the ``Event`` key in your Routes configuration are added here loop:begin({ default = RunService.Heartbeat }) Finally, in a Matter System we can use our routes.luau ModuleScript to access our Routes and use them within our Systems. systems/exampleSystem.luau local routes = require(&quot;routes.luau&quot;) local PlayerLoaded = routes.PlayerLoaded local function exampleSystem(world) -- Query through every networking call that frame on the Server for i, player, ...data in PlayerLoaded:query() do -- Do something end -- Query through every networking call that frame on the Client for i, _, ...data in PlayerLoaded:query() do -- Do something end -- Send data from the Client to the Server PlayerLoaded:send(...data) -- Send data to a Client from the Server PlayerLoaded:send(...data):to(Player) end ","keywords":""}]