"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[959],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),s=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(i.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),d=s(n),m=a,h=d["".concat(i,".").concat(m)]||d[m]||p[m]||o;return n?r.createElement(h,l(l({ref:t},c),{},{components:n})):r.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=m;var u={};for(var i in t)hasOwnProperty.call(t,i)&&(u[i]=t[i]);u.originalType=e,u[d]="string"==typeof e?e:a,l[1]=u;for(var s=2;s<o;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>l});var r=n(67294),a=n(86010);const o={tabItem:"tabItem_Ymn6"};function l(e){let{children:t,hidden:n,className:l}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(o.tabItem,l),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>w});var r=n(87462),a=n(67294),o=n(86010),l=n(12466),u=n(16550),i=n(91980),s=n(67392),c=n(50012);function d(e){return function(e){return a.Children.map(e,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:a}}=e;return{value:t,label:n,attributes:r,default:a}}))}function p(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??d(n);return function(e){const t=(0,s.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const r=(0,u.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,i._X)(o),(0,a.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function y(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,o=p(e),[l,u]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[i,s]=h({queryString:n,groupId:r}),[d,y]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,c.Nk)(n);return[r,(0,a.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:r}),b=(()=>{const e=i??d;return m({value:e,tabValues:o})?e:null})();(0,a.useLayoutEffect)((()=>{b&&u(b)}),[b]);return{selectedValue:l,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);u(e),s(e),y(e)}),[s,y,o]),tabValues:o}}var b=n(72389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function g(e){let{className:t,block:n,selectedValue:u,selectValue:i,tabValues:s}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,l.o5)(),p=e=>{const t=e.currentTarget,n=c.indexOf(t),r=s[n].value;r!==u&&(d(t),i(r))},m=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t)},s.map((e=>{let{value:t,label:n,attributes:l}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:u===t?0:-1,"aria-selected":u===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:p},l,{className:(0,o.Z)("tabs__item",f.tabItem,l?.className,{"tabs__item--active":u===t})}),n??t)})))}function k(e){let{lazy:t,children:n,selectedValue:r}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function v(e){const t=y(e);return a.createElement("div",{className:(0,o.Z)("tabs-container",f.tabList)},a.createElement(g,(0,r.Z)({},e,t)),a.createElement(k,(0,r.Z)({},e,t)))}function w(e){const t=(0,b.Z)();return a.createElement(v,(0,r.Z)({key:String(t)},e))}},65701:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>u,metadata:()=>s,toc:()=>d});var r=n(87462),a=(n(67294),n(3905)),o=n(74866),l=n(85162);const u={sidebar_position:1},i="Routes",s={unversionedId:"getting-started/routes",id:"getting-started/routes",title:"Routes",description:"Routes are the core component of Net, these objects are how you send or receive data through Net.",source:"@site/docs/getting-started/routes.mdx",sourceDirName:"getting-started",slug:"/getting-started/routes",permalink:"/Net/docs/getting-started/routes",draft:!1,editUrl:"https://github.com/YetAnotherClown/Net/edit/main/docs/getting-started/routes.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"defaultSidebar",previous:{title:"Introduction",permalink:"/Net/docs/intro"},next:{title:"Middleware",permalink:"/Net/docs/getting-started/middleware"}},c={},d=[{value:"Configuration",id:"configuration",level:2},{value:"Type-checking",id:"type-checking",level:2},{value:"Sending",id:"sending",level:2},{value:"Querying",id:"querying",level:2}],p={toc:d},m="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"routes"},"Routes"),(0,a.kt)("p",null,"Routes are the core component of Net, these objects are how you send or receive data through Net.\nThese are uniquely identified and come with no overhead, so you're encouraged to create as many as you need as if you were creating individual RemoteEvents."),(0,a.kt)("h2",{id:"configuration"},"Configuration"),(0,a.kt)("p",null,"There are a few ways you can configure your Routes:"),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"channel",label:"Channel",default:!0,mdxType:"TabItem"},(0,a.kt)("p",null,"All Routes run on one of two channels: Reliable & Unreliable.",(0,a.kt)("br",null),"These channels change the way your packets are sent over the network."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Channel"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Reliable"),(0,a.kt)("td",{parentName:"tr",align:null},"Packets are never dropped, and are always ordered.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Unreliable"),(0,a.kt)("td",{parentName:"tr",align:null},"Packets may be dropped per frame, but are always ordered per frame."))))),(0,a.kt)(l.Z,{value:"event",label:"Event",mdxType:"TabItem"},(0,a.kt)("p",null,"The ",(0,a.kt)("code",{lang:"lua"},"Event")," field is only used when you're using the Matter ECS.",(0,a.kt)("br",null),"This is used internally in the ",(0,a.kt)("code",{lang:"lua"},"Net.start(loop,  { routes })")," hook to schedule your Routes."),(0,a.kt)("p",null,"You can safely ignore this field if you do not use the ",(0,a.kt)("code",{lang:"lua"},"Net.start(loop,  { routes })")," hook."))),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"type-checking"},"Type-checking"),(0,a.kt)("p",null,"Routes can be Type-checked to provide intellisense and auto-completion by providing a type annotation when creating your Routes."),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"lua",label:"Luau",default:!0,mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local Net = require("Net.luau")\n\nlocal Route = Net.Route\ntype Route<U...> = Net.Route<U...>;\n\nlocal route: Route<number, string, boolean> = Route.new()\n\n-- Send will expect the types annotated\nroute:send(1, "Hello, world!", true)\n\n-- The returned arguments are typed\nfor pos, num, str, bool in route:query() do\n  -- Do something\nend\n')),(0,a.kt)("p",null,"In this example, the Route is annotated with the types ",(0,a.kt)("inlineCode",{parentName:"p"},"number, string, boolean"),", this means that our methods like ",(0,a.kt)("inlineCode",{parentName:"p"},"Route:query()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Route:send()")," will return or expect\nthese types."),(0,a.kt)("p",null,"This will enable auto-completion and type-checking when working with your Routes, as such it is encouraged you enable Strict Typing to compliment these features.")),(0,a.kt)(l.Z,{value:"ts",label:"Typescript",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Route } from "@rbxts/yetanothernet";\n\nconst route: Route<[number, boolean, string]> = new Route({\n  Channel: "Reliable",\n  Event: undefined,\n});\n\n// Send will expect the types annotated\nroute.send(1, "Hello, world!", true)\n\n// The returned arguments are typed\nfor (const [pos, sender, num, str, bool] of route.query()) {\n  // Do something\n}\n')),(0,a.kt)("p",null,"In this example, the Route is annotated with the types ",(0,a.kt)("inlineCode",{parentName:"p"},"number, string, boolean"),", this means that our methods like ",(0,a.kt)("inlineCode",{parentName:"p"},"Route.query()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Route.send()")," will return or expect\nthese types."),(0,a.kt)("p",null,"This will enable auto-completion and type-checking when working with your Routes, as such it is encouraged you enable Strict Typing to compliment these features."))),(0,a.kt)("h2",{id:"sending"},"Sending"),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"lua",label:"Luau",default:!0,mdxType:"TabItem"},(0,a.kt)("p",null,"You can use ",(0,a.kt)("inlineCode",{parentName:"p"},"Route:send(...data)")," to send data over the Route. This data will be processed next frame, which is when you'll be able to query it on the receiving end."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local Net = require("Net.luau")\ntype Net<U...> = Net.Net<U...>\n\nlocal Route: Net<number, string, boolean> = Net.new()\n\nRoute:send(5, true, "Hello, world!")\n')),(0,a.kt)("p",null,"By default, ",(0,a.kt)("inlineCode",{parentName:"p"},"Route:send()")," will send the Packet of data to all Clients when used on the Server. You can specify a ",(0,a.kt)("inlineCode",{parentName:"p"},"Player")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"{ Player }")," to send it to by using ",(0,a.kt)("inlineCode",{parentName:"p"},"Route:send():to(recipient)"),".")),(0,a.kt)(l.Z,{value:"ts",label:"Typescript",mdxType:"TabItem"},(0,a.kt)("p",null,"You can use ",(0,a.kt)("inlineCode",{parentName:"p"},"Route.send(...data)")," to send data over the Route. This data will be processed next frame, which is when you'll be able to query it on the receiving end."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import Route from "@rbxts/yetanothernet";\n\nconst route: Route<[number, boolean, string]> = new Route({\n  Channel: "Reliable",\n  Event: undefined,\n});\n\nRoute.send(5, true, "Hello, world!")\n')),(0,a.kt)("p",null,"By default, ",(0,a.kt)("inlineCode",{parentName:"p"},"Route.send()")," will send the Packet of data to all Clients when used on the Server. You can specify a ",(0,a.kt)("inlineCode",{parentName:"p"},"Player")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"[Player]")," to send it to by using ",(0,a.kt)("inlineCode",{parentName:"p"},"Route.send().to(recipient)"),"."))),(0,a.kt)("h2",{id:"querying"},"Querying"),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"lua",label:"Luau",default:!0,mdxType:"TabItem"},(0,a.kt)("p",null,"Querying is simple, you can query for Packets by using ",(0,a.kt)("inlineCode",{parentName:"p"},"Route:query()")," which will return an iterator that will output ",(0,a.kt)("inlineCode",{parentName:"p"},"position, sender, ...data")," in your for loop."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local Net = require("Net.luau")\ntype Net<U...> = Net.Net<U...>\n\nlocal Route: Net<number, string, boolean> = Net.new()\n\nfor pos, sender, num, str, bool in Route:query() do\n  -- Do something\nend\n')),(0,a.kt)("p",null,"When you call the ",(0,a.kt)("inlineCode",{parentName:"p"},"query")," method, it will take a snapshot of all Packets from the previous frame and filter it for you, such as only returning Packets from the Route the method was called on.\nOr, you can also filter out senders by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"Route:query():from(...sender)")," on the QueryResult and putting any values of type ",(0,a.kt)("inlineCode",{parentName:"p"},"{ Player } | Player | Net.server")," in the arguments.")),(0,a.kt)(l.Z,{value:"ts",label:"Typescript",mdxType:"TabItem"},(0,a.kt)("p",null,"Querying is simple, you can query for Packets by using ",(0,a.kt)("inlineCode",{parentName:"p"},"Route.query()")," which will return an iterator that will output ",(0,a.kt)("inlineCode",{parentName:"p"},"position, sender, ...data")," in your for loop."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Route } from "@rbxts/yetanothernet";\n\nconst route: Route<[number, boolean, string]> = new Route({\n  Channel: "Reliable",\n  Event: undefined,\n});\n\nfor (const [pos, sender, num, str, bool] of route.query()) {\n  // Do something\n}\n')),(0,a.kt)("p",null,"When you call the ",(0,a.kt)("inlineCode",{parentName:"p"},"query")," function, it will take a snapshot of all Packets from the previous frame and filter it for you, such as only returning Packets from the Route the function was called on.\nOr, you can also filter out senders by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"Route.query().from(...sender)")," on the QueryResult and putting any values of type ",(0,a.kt)("inlineCode",{parentName:"p"},"[Player] | Player | Net.server")," in the arguments."))))}h.isMDXComponent=!0}}]);