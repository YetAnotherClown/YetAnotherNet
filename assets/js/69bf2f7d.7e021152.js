"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[425],{69153:e=>{e.exports=JSON.parse('{"functions":[{"name":"_sendPayloads","desc":"Before sending the Payloads over the network, this method will\\nattempt to serialize the Payloads into buffers. If the payload\\nfails to serialize, it will send the unserialized payload\\ninstead.","params":[],"returns":[],"function_type":"method","source":{"line":139,"path":"lib/Bridge.luau"}},{"name":"_processOutgoingQueue","desc":"This method will process the OutgoingQueue and pack it into Payloads for\\nuse in Bride:_sendPayloads()","params":[],"returns":[{"desc":"","lua_type":"ClientPayloads, ServerPayload"}],"function_type":"method","source":{"line":251,"path":"lib/Bridge.luau"}},{"name":"snapshot","desc":"Returns a copy of the snapshot.\\nThe snapshot is a snapshot of the last frame\'s IncomingQueue.","params":[],"returns":[],"function_type":"method","source":{"line":290,"path":"lib/Bridge.luau"}},{"name":"beginFrame","desc":"The IncomingQueue is a queue that collects all the incoming data from a frame,\\nthe use of this function creates a new snapshot of it and then empties the queue.\\nThis snapshot is what your Routes will use to read the data that was sent in the last frame.\\n\\n:::note\\nAssuming all scheduling code and the use of `send` and `query` are running on the Heartbeat,\\nthis will not actually cause any delay for when you recieve your data, as Replication Events are sent\\nafter the Heartbeat.\\nSee [Schedular Priority](https://create.roblox.com/docs/studio/microprofiler/task-scheduler#scheduler-priority)\\nfor more information.\\n:::\\n\\n:::warning\\nYou should only use this function if creating custom scheduling behavior\\nsimilar to the Hooks API, which you should use instead of trying to achieve\\nthis behavior using the Bridge itself.\\n:::","params":[],"returns":[],"function_type":"method","source":{"line":316,"path":"lib/Bridge.luau"}},{"name":"endFrame","desc":"The OutgoingQueue collects all the outgoing data from a frame, when you do\\n`Route:send()` the data is not immediately sent over the network, it is instead\\nbatched and sent over the network at the end of the frame.\\n\\n:::note\\nAssuming all scheduling code and the use of `send` and `query` are running on the Heartbeat,\\nthis will not actually cause any delay for when you recieve your data, as Replication Events are sent\\nafter the Heartbeat.\\nSee [Schedular Priority](https://create.roblox.com/docs/studio/microprofiler/task-scheduler#scheduler-priority)\\nfor more information.\\n:::\\n\\n:::warning\\nYou should only use this function if creating custom scheduling behavior\\nsimilar to the Hooks API, which you should use instead of trying to achieve\\nthis behavior using the Bridge itself.\\n:::","params":[],"returns":[],"function_type":"method","source":{"line":346,"path":"lib/Bridge.luau"}},{"name":"_processIncoming","desc":"This method will process any packages sent over either channel of the Bridge.\\nIt will attempt to deserialize the package and add it to our IncomingQueue.","params":[],"returns":[],"function_type":"method","private":true,"source":{"line":359,"path":"lib/Bridge.luau"}},{"name":"_initialize","desc":"Assigns starting values, creates connections for channels, and other initialization work.\\n\\nThis is intentionally abstracted out of Bridge.new() so we can overwrite Bridge.new()\\nduring mocking without having to rewrite the contents of this function.","params":[],"returns":[],"function_type":"method","private":true,"source":{"line":410,"path":"lib/Bridge.luau"}},{"name":"_getContext","desc":"This is a wrapper around RunService:IsServer() and RunService:IsClient()\\nto enable us to mock the Click/Server Boundary during Unit Testing.","params":[],"returns":[{"desc":"","lua_type":"\\"client\\" | \\"server\\""}],"function_type":"method","private":true,"source":{"line":449,"path":"lib/Bridge.luau"}},{"name":"_getRemotes","desc":"When mocking, we use Mock RemoteEvents instead of actual RemoteEvents,\\nthis function allows us to replace the Remotes with these Mock RemoteEvents\\nwithout having to rewrite any functionality of the library during mocking.","params":[],"returns":[{"desc":"","lua_type":"RemoteEvent, UnreliableRemoveEvent"}],"function_type":"method","private":true,"source":{"line":464,"path":"lib/Bridge.luau"}},{"name":"_isPlayer","desc":"Since we mock the Client/Server Boundary in Unit Tests, we also fake the\\nPlayers in our games with Mock Players. This function allows us to\\nswitch out the typechecking for Players with typechecking for Mock Players.","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","private":true,"source":{"line":506,"path":"lib/Bridge.luau"}},{"name":"new","desc":"This creates a new Bridge and performs initialization work.\\n\\nYou should not create or use Bridges in your code unless creating\\ncustom scheduling behavior similar to hooks. If you can use the\\nnative Hooks API, it is recommended you do instead of using the Bridge\\ndirectly.\\n\\nCreating a new Bridge does not create new Remotes, all Remotes are shared\\nby all Bridges. During Mocking, we can change this behavior by overwriting\\nthe Bridge:_getRemotes() method.","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":527,"path":"lib/Bridge.luau"}}],"properties":[],"types":[],"name":"Bridge","desc":"Bridges are the Transport and SerDes Layer of YetAnotherNet, responsible for\\nserializing and deserializing data as well as sending it over the network.\\n\\nThe Bridge class should only be used internally within the Library, when\\ncreating behavior identical to hooks, or when performing Unit/Integration Tests.\\n\\nThe Bridge is structured in a way to enable simple mocking using Jest-Lua.","source":{"line":110,"path":"lib/Bridge.luau"}}')}}]);