"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[54],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),s=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(i.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},b=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),d=s(n),b=a,m=d["".concat(i,".").concat(b)]||d[b]||p[b]||o;return n?r.createElement(m,l(l({ref:t},c),{},{components:n})):r.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=b;var u={};for(var i in t)hasOwnProperty.call(t,i)&&(u[i]=t[i]);u.originalType=e,u[d]="string"==typeof e?e:a,l[1]=u;for(var s=2;s<o;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}b.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>l});var r=n(67294),a=n(86010);const o={tabItem:"tabItem_Ymn6"};function l(e){let{children:t,hidden:n,className:l}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(o.tabItem,l),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>k});var r=n(87462),a=n(67294),o=n(86010),l=n(12466),u=n(16550),i=n(91980),s=n(67392),c=n(50012);function d(e){return function(e){return a.Children.map(e,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:a}}=e;return{value:t,label:n,attributes:r,default:a}}))}function p(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??d(n);return function(e){const t=(0,s.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function b(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const r=(0,u.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,i._X)(o),(0,a.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,o=p(e),[l,u]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!b({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[i,s]=m({queryString:n,groupId:r}),[d,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,c.Nk)(n);return[r,(0,a.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:r}),g=(()=>{const e=i??d;return b({value:e,tabValues:o})?e:null})();(0,a.useLayoutEffect)((()=>{g&&u(g)}),[g]);return{selectedValue:l,selectValue:(0,a.useCallback)((e=>{if(!b({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);u(e),s(e),f(e)}),[s,f,o]),tabValues:o}}var g=n(72389);const h={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:n,selectedValue:u,selectValue:i,tabValues:s}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,l.o5)(),p=e=>{const t=e.currentTarget,n=c.indexOf(t),r=s[n].value;r!==u&&(d(t),i(r))},b=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t)},s.map((e=>{let{value:t,label:n,attributes:l}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:u===t?0:-1,"aria-selected":u===t,key:t,ref:e=>c.push(e),onKeyDown:b,onClick:p},l,{className:(0,o.Z)("tabs__item",h.tabItem,l?.className,{"tabs__item--active":u===t})}),n??t)})))}function v(e){let{lazy:t,children:n,selectedValue:r}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function w(e){const t=f(e);return a.createElement("div",{className:(0,o.Z)("tabs-container",h.tabList)},a.createElement(y,(0,r.Z)({},e,t)),a.createElement(v,(0,r.Z)({},e,t)))}function k(e){const t=(0,g.Z)();return a.createElement(w,(0,r.Z)({key:String(t)},e))}},95033:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>u,metadata:()=>s,toc:()=>d});var r=n(87462),a=(n(67294),n(3905)),o=n(74866),l=n(85162);const u={sidebar_position:2},i="Middleware",s={unversionedId:"getting-started/middleware",id:"getting-started/middleware",title:"Middleware",description:"Middleware is a powerful feature of Net that allows you to validate types and serialize/deserialize data before it is processed when sending and receiving data.",source:"@site/docs/getting-started/middleware.mdx",sourceDirName:"getting-started",slug:"/getting-started/middleware",permalink:"/Net/docs/getting-started/middleware",draft:!1,editUrl:"https://github.com/YetAnotherClown/Net/edit/main/docs/getting-started/middleware.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"defaultSidebar",previous:{title:"Routes",permalink:"/Net/docs/getting-started/routes"},next:{title:"Hooks",permalink:"/Net/docs/getting-started/hooks"}},c={},d=[{value:"Compression",id:"compression",level:2}],p={toc:d},b="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(b,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"middleware"},"Middleware"),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"lua",label:"Luau",default:!0,mdxType:"TabItem"},(0,a.kt)("p",null,"Middleware is a powerful feature of Net that allows you to validate types and serialize/deserialize data before it is processed when sending and receiving data."),(0,a.kt)("p",null,"To create Middleware, you can specify a function in either ",(0,a.kt)("inlineCode",{parentName:"p"},"Route:addIncomingMiddleware()")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Route:addOutgoingMiddleware()"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local Net = require("Net.luau")\n\nlocal Route = Net.Route\ntype Route<U...> = Net.Route<U...>;\n\nlocal route: Route<number, string, boolean> = Route.new()\n\n-- Sets a function to be ran on Incoming packets before they are received over the network\nroute:addIncomingMiddleware(function(number: unknown, string: unknown, boolean: unknown)\n    -- Do something, e.g., Validate Types\n\n    return number, string, boolean\nend)\n\n-- Sets a function to be ran on Outgoing packets before they are sent over the network\nroute:addOutgoingMiddleware(function(number: number, string: string, boolean: boolean)\n    -- Do something, e.g., Compress data\n\n    return number, string, boolean\nend)\n')),(0,a.kt)("p",null,"To validate your types, you can return the values in order to allow it to be processed, or you can drop the packet by returning ",(0,a.kt)("inlineCode",{parentName:"p"},"nil"),". Dropped packets will never reach your code, meaning you can ensure that the types your code receives are always the types you expect.")),(0,a.kt)(l.Z,{value:"ts",label:"Typescript",mdxType:"TabItem"},(0,a.kt)("p",null,"Middleware is a powerful feature of Net that allows you to validate types and serialize/deserialize data before it is processed when sending and receiving data."),(0,a.kt)("p",null,"To create Middleware, you can specify a function in either ",(0,a.kt)("inlineCode",{parentName:"p"},"Route.addIncomingMiddleware()")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Route.addOutgoingMiddleware()"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Route } from "@rbxts/yetanothernet";\n\nconst route: Route<[number, boolean, string]> = new Route({\n  Channel: "Reliable",\n  Event: undefined,\n});\n\n// Sets a function to be ran on Incoming packets before they are received over the network\nroute.addIncomingMiddleware(function (number: unknown, string: unknown, boolean: unknown) {\n    // Do something, e.g., Validate Types\n\n    return $tuple(number, string, boolean)\n})\n\n// Sets a function to be ran on Outgoing packets before they are sent over the network\nroute.addOutgoingMiddleware(function (number: number, string: string, boolean: boolean) {\n    // Do something, e.g., Compress data\n\n    return $tuple(number, string, boolean)\n})\n')),(0,a.kt)("p",null,"To validate your types, you can return the values in order to allow it to be processed, or you can drop the packet by returning ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),". Dropped packets will never reach your code, meaning you can ensure that the types your code receives are always the types you expect."))),(0,a.kt)("h2",{id:"compression"},"Compression"),(0,a.kt)("p",null,"To compress/decompress your data, you can use a library like ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Data-Oriented-House/Squash"},"Squash")," to serialize and deserialize your data. Simply return the types in order as a tuple, you can use the event parameter to determine whether to compress or decompress your data."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local Squash = require("Squash.luau")\nlocal Net = require("Net.luau")\ntype Net<U...> = Net.Net<U...>\n\nlocal route: Net<string, number> = Net.new({\n    Channel = "Reliable",\n})\n\n-- Deserialize Packets before returning\nroute:addIncomingMiddleware(function(str, bool)\nlocal values: { any } = {}\n    local alphabet = Squash.string.alphabet(str)\n\n    -- Type-check returned values;\n    -- Squash serializes types into other types, like string\n    if type(str) ~= "string" or type(boolean) ~= "string" then\n        return\n    end\n\n    values = {\n        Squash.string.des(str, alphabet),\n        Squash.boolean.des(boolean),\n    }\n\n    return table.unpack(values)\nend)\n\n-- Serialize Packets before sending\nroute:addOutgoingMiddleware(function(str, bool)\nlocal values: { any } = {}\n    local alphabet = Squash.string.alphabet(str)\n\n    -- Type-check sent values,\n    -- Should be of the provided types U... in Net<U...>\n    if type(str) ~= "string" or type(boolean) ~= "boolean" then\n        return\n    end\n\n    values = {\n        Squash.string.ser(str, alphabet),\n        Squash.boolean.ser(boolean),\n    }\n\n    return table.unpack(values)\nend)\n')))}m.isMDXComponent=!0}}]);